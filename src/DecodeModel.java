import javafx.scene.control.Alert;

import java.io.*;
import java.nio.ByteBuffer;
import java.util.Arrays;

import static javafx.scene.control.Alert.AlertType.ERROR;
import static javafx.scene.control.Alert.AlertType.INFORMATION;


/**
 * The model to decode a payload in a cover image.
 */
public class DecodeModel {

    // A reference to a controller for the decode GUI
    private DecodeController decodeController;
    // A reference to the cover image object
    private AppFileInterface coverImg;

    /**
     * Initialises the model when the controller calls this.
     * Creates instances of a cover image, as well as a reference to the decode controller.
     *
     * @param controller
     */
    protected void setController(DecodeController controller) {
        this.decodeController = controller;
        coverImg = new CoverImg();
    }

    /**
     * Checks and sets a passed file as the cover image.
     *
     * @param f
     */
    public void stageCoverImg(File f) {
        if (f == null) return;
        System.out.println(f.getName() + "\nStaged to conceal a file.");
        // Sets the file in the coverImg object
        if (coverImg.setFile(f) == null) {
            new Alert(ERROR, "The cover image is not a 24 bit .bmp or .dib file. Please select another file.").show();
            return;
        }
        decodeController.setCoverImg(f);
    }

    /**
     * Will do the decoding, huzzah!
     */
    public void decodeSteganograph() {
        /*
        Confirms a cover image has been received and returns if not
         */
        if (!coverImg.isSet()) {
            new Alert(ERROR, "Decoding failed, no image supplied").show();
            return;
        }

        /*
        Extracts byte array from cover image and removes BMP header
         */
        byte[] payload = coverImg.getByteArray();
        payload = Arrays.copyOfRange(payload, 54, payload.length);

        // Calculate length of payload using extract bytes method and converts to integer
        int lengthnum = ByteBuffer.wrap(extractBytes(Arrays.copyOfRange(payload, 0, 32))).getInt();
        System.out.println("Payload length: " + lengthnum);

        /*
        Confirms extracted length is of an expected amount
         */
        if (lengthnum < 0) {
            new Alert(ERROR, "Payload decoding failed. Decoded length was < 0").show();
            return;
        }

        if (lengthnum > (payload.length)) {
            new Alert(ERROR, "Payload decoding failed. Decoded length was greater than the size of the file").show();
            return;
        }

        /*
        Similar to above, extracts extension from bytes 32-96 and converts to a string
         */
        byte[] extension = extractBytes(Arrays.copyOfRange(payload, 32, 96));
        String extensionType = new String(extension);
        extensionType = extensionType.trim();
        String filename = "decoded." + extensionType;

        /*
        Extracting payload
         */
        payload = extractBytes(Arrays.copyOfRange(payload, 96, lengthnum + 96));

        /*
        Writing payload to file, catching any exceptions generated by file output stream
         */
        try {
            FileOutputStream fileOutputStream = new FileOutputStream(filename);
            fileOutputStream.write(payload);
            new Alert(INFORMATION, "Payload successfully decoded to the project directory as " + filename + ".").show();
        } catch (FileNotFoundException e) {
            new Alert(ERROR, "File Not Found Exception occurred").show();
        } catch (IOException e) {
            new Alert(ERROR, "IO Exception occurred").show();
        }
    }

    /**
     * Method to remove payload from the least significant bits of a byte array
     * @param bytes a byte array of length n*8 where n is a positive integer
     * @return a byte array of the least significant bits of the provided byte array with length n/8
     */
    private byte[] extractBytes(byte[] bytes) {
        // Make new byte array to be returned
        byte[] returnByteArray = new byte[bytes.length / 8];
        // Work through every 8 bytes in 'bytes' to form the extracted byte
        for (int i = 0; i < bytes.length; i += 8) {
            byte newByte = 0;
            for (int j = 0; j < 8; j++) {
                // Perform and on each byte with 0x1 (00000001) and shift it left to it's position in the new byte
                newByte = (byte) (newByte + ((bytes[i + j] & 0x1) << (7 - j)));
            }
            // Add new byte to the return byte array
            returnByteArray[i / 8] = newByte;
        }
        return returnByteArray;
    }


}
